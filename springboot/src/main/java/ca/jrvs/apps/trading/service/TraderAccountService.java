package ca.jrvs.apps.trading.service;

import ca.jrvs.apps.trading.dao.AccountDao;
import ca.jrvs.apps.trading.dao.PositionDao;
import ca.jrvs.apps.trading.dao.SecurityOrderDao;
import ca.jrvs.apps.trading.dao.TraderDao;
import ca.jrvs.apps.trading.model.domain.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Date;
import java.util.*;

@Service
public class TraderAccountService {

    private TraderDao traderDao;
    private AccountDao accountDao;
    private PositionDao positionDao;
    private SecurityOrderDao securityOrderDao;

    @Autowired
    public TraderAccountService(TraderDao traderDao, AccountDao accountDao, PositionDao positionDao, SecurityOrderDao securityOrderDao){
        this.traderDao = traderDao;
        this.accountDao = accountDao;
        this.positionDao = positionDao;
        this.securityOrderDao = securityOrderDao;
    }

    /**
     * Create a new trader and initialize a new account with a zero starting balance (amount).
     * @param trader cannot be null, and all fields cannot be null except for ID (autogenerated by database)
     * @return traderAccountView
     * @throws IllegalArgumentException if a trader has null fields or ID is not null.
     */
    public TraderAccountView createTraderAndAccount(Trader trader){
        Account account;
        TraderAccountView newTraderAndAccount = new TraderAccountView();

        if (trader.getId() == null){
            boolean validTrader = validateTraderProfile(trader);
            if (validTrader){
                trader = traderDao.save(trader);
                Integer id = trader.getId();
                account = createAccount(id);
                newTraderAndAccount = createTraderAccountView(trader, account);
            }
        } else {
            throw new IllegalArgumentException("Cannot create a new trader account. Given trader profile already has an established ID.");
        }

        return newTraderAndAccount;
    }

    /**
     * Helper function. Verifies that the trader profile does not have any empty or null fields.
     * @param trader profile
     * @return true if trader does not contain any empty or null fields.
     */
    private boolean validateTraderProfile(Trader trader){
        Integer id = trader.getId();
        String firstName = trader.getFirstName();
        String lastName = trader.getLastName();
        Date dateOfBirth = trader.getDateOfBirth();
        String country = trader.getCountry();
        String email = trader.getEmail();

        if (firstName == null || firstName.equals("")){
            throw new IllegalArgumentException("Trader first name field is missing.");
        } else if (lastName == null || lastName.equals("")){
            throw new IllegalArgumentException("Trader last name field is missing.");
        } else {
            boolean validFirstName = validateName(firstName);
            boolean validLastName = validateName(lastName);
            if (!validFirstName && !validLastName){
                throw new IllegalArgumentException("Trader first and last names are invalid.");
            }
        }

        if (dateOfBirth == null){
            throw new IllegalArgumentException("Trader DOB field is missing.");
        } if (country == null || country.equals("")){
            throw new IllegalArgumentException("Trader country field is missing.");
        } else {
            // Checks that the country string is for a valid country.
            // If invalid, helper method will throw its specific IllegalArgumentException.
            validateCountry(country);
        }if (email == null || email.equals("")){
            throw new IllegalArgumentException("Trader e-mail field is missing.");
        } else {
            boolean validEmailAddress = validateEmailAddress(email);
            if (!validEmailAddress){
                throw new IllegalArgumentException("Trader e-mail is invalid.");
            }
        }

        return true;
    }

    /**
     * Helper function. Checks that name field contains only alphabet characters
     * and consists of a minimum of 3 and maximum of 50 characters.
     * @param name
     * @return
     */
    private boolean validateName(String name){
        return name.matches("[A-Za-z]{3,50}");
    }

    /**
     * Helper function. Checks that the country field contains the name of a valid country.
     * @param country
     * @return
     */
    private boolean validateCountry(String country){
        String[] countryCodes = Locale.getISOCountries();
        String[] countries = new String[countryCodes.length];

        for (int i = 0; i < countryCodes.length; i++){
            Locale nation = new Locale("", countryCodes[i]);
            countryCodes[i] = nation.getCountry();
        }

        List<String> validCountries = Arrays.asList(countries);
        if (!validCountries.contains(country)) {
            throw new IllegalArgumentException("Trader account's country field is invalid. Country not recognized.");
        }

        return true;
    }

    /**
     * Helper function. Validates given email address.
     * @param email
     * @return
     */
    private boolean validateEmailAddress(String email){
        // e-mail regex pattern taken from
        // https://howtodoinjava.com/regex/java-regex-validate-email-address/
        return email.matches("^[a-zA-Z0-9_!#$%&’*+/=?`{|}~^-]+(?:\\.[a-zA-Z0-9_!#$%&’*+/=?`{|}~^-]+)*@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$");
    }

    /**
     * Helper function. Creates a new account with the same ID number as the given trader ID,
     * with an initial balance of zero.
     * @param traderID
     * @return newly created account.
     */
    private Account createAccount(Integer traderID){
        Account account = new Account();
        account.setTraderID(traderID);
        account.setAmount(0.0);
        accountDao.save(account);

        return account;
    }

    /**
     * Helper function. Creates a Trader Account view given a trader profile and its associated account.
     * @param trader profile
     * @param account associated with the trader profile
     * @return
     */
    private TraderAccountView createTraderAccountView(Trader trader, Account account){
        TraderAccountView traderAccountView = new TraderAccountView();
        traderAccountView.setTrader(trader);
        traderAccountView.setAccount(account);
        return traderAccountView;
    }

    /**
     * Delete a trader if it has no open positions and a zero cash balance.
     *
     * @param traderID must not be null
     * @throws IllegalArgumentException if a trader ID is null or not found, or unable to delete.
     */
    public void deleteTraderByID(Integer traderID){

        if (traderID == null){
            throw new IllegalArgumentException("Trader ID cannot be null.");
        }

        if (traderDao.existsById(traderID)) {
            Optional<Trader> trader = traderDao.findById(traderID);
            Account account = accountDao.findById(traderID).get();

            if (account.getAmount() != 0){
                throw new IllegalArgumentException("Cannot delete account. Trader balance is not zero.");
            }

            try {
                Optional<Position> position = positionDao.findById(traderID);
                if (position.isPresent()) {
                    if (position.get().getPosition() != 0){
                        throw new IllegalArgumentException("Cannot delete account. Trader has open positions.");
                    }

                    List<SecurityOrder> securityOrders = new ArrayList<SecurityOrder>();
                    securityOrders = securityOrderDao.findAllSecurityOrders(account);
                    securityOrders.forEach(order -> securityOrderDao.delete(order));
                }
                positionDao.delete(position.get());
                accountDao.delete(account);
                traderDao.delete(trader.get());
            } catch (IllegalArgumentException e){
                throw new IllegalArgumentException("Unable to delete trader account.");
            }
        } else {
            throw new IllegalArgumentException("ID does not exist.");
        }

    }

    /**
     * Deposit a fund to an account by trader ID.
     *
     * @param traderID must not be null.
     * @param fund must be non-zero and greater than zero.
     * @return updated Account.
     * @throws IllegalArgumentException if traderID is null or not found, and fund is
     * less or equal to zero.
     */
    public Account deposit(Integer traderID, Double fund){
        Optional<Account> account = accountDao.findById(traderID);
        String transactionType = "deposit";

        if (fundsAreValid(fund)){
            if (account.isPresent()){
                updateFunds(account, fund, transactionType);
            }
        } else {
            throw new IllegalArgumentException("Funds cannot be zero or negative.");
        }

        return account.get();
    }

    /**
     * Withdraw a fund from an account by trader ID.
     *
     * @param traderID
     * @param fund
     * @return
     */
    public Account withdraw(Integer traderID, Double fund){
        Optional<Account> account = accountDao.findById(traderID);
        String transactionType = "withdraw";

        if (fundsAreValid(fund)){
            if (account.isPresent()){
                updateFunds(account, fund, transactionType);
            }
        } else {
            throw new IllegalArgumentException("Funds cannot be zero or negative.");
        }

        return account.get();
    }

    /**
     * Helper function. Verifies that the fund amount is valid.
     * @param funds specified for the transaction.
     * @return
     */
    private boolean fundsAreValid(Double funds){
        if (funds > 0){
            return true;
        } else {
            return false;
        }
    }

    /**
     * Helper function. Updates account balances after a transaction completes.
     * @param validatedAccount
     * @param fund specified for the transaction.
     * @param transactionType must be either "deposit" or "withdraw."
     */
    private void updateFunds(Optional<Account> validatedAccount, Double fund, String transactionType){
        Account account = validatedAccount.get();
        Double currentBalance = account.getAmount();
        Double updatedBalance;

        if (transactionType.equals("deposit")){
            updatedBalance = account.getAmount() + fund;
        } if (transactionType.equals("withdrawl") && sufficientFunds(fund, currentBalance)){
            updatedBalance = account.getAmount() - fund;
        } else {
            throw new IllegalArgumentException("Unexpected transaction type. Please deposit or withdraw only.");
        }

        if (updatedBalance < 0){
            throw new IllegalArgumentException("Failed withdrawal. You cannot withdraw more funds than your current account balance.");
        } else {
            accountDao.updateAmountById(account.getId(), updatedBalance);
        }
    }

    /**
     * Helper function. Verifies that an account has sufficient funds to
     * start/finish a transaction.
     * @param funds specified for the transaction.
     * @param accountBalance of the acting account.
     * @return
     */
    private boolean sufficientFunds(Double funds, Double accountBalance){
        if (funds > accountBalance){
            return false;
        }
        else {
            return true;
        }
    }
}
